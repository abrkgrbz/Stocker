{
  "C:/Users/PC/source/repos/Stocker/stocker-web/src/services/cache.service.ts": [
    {
      "type": "genericAny",
      "line": 1,
      "code": "/**\r * Cache Service for API responses\r * Implements in-memory caching with TTL support\r */\rinterface CacheEntry<T> {\r  data: T;\r  timestamp: number;\r  ttl: number;\r}\rclass CacheService {\r  private cache: Map<string, CacheEntry<any>> = new Map();\r  private defaultTTL = 5 * 60 * 1000; // 5 minutes default\r  /**\r   * Get data from cache\r   */\r  get<T>(key: string): T | null {\r    const entry = this.cache.get(key);\r    if (!entry) {\r      return null;\r    }\r    // Check if cache is expired\r    if (Date.now() - entry.timestamp > entry.ttl) {\r      this.cache.delete(key);\r      return null;\r    }\r    return entry.data as T;\r  }\r  /**\r   * Set data in cache\r   */\r  set<T>(key: string, data: T, ttl?: number): void {\r    this.cache.set(key, {\r      data,\r      timestamp: Date.now(),\r      ttl: ttl || this.defaultTTL,\r    });\r  }\r  /**\r   * Check if key exists and is valid\r   */\r  has(key: string): boolean {\r    const entry = this.cache.get(key);\r    if (!entry) {\r      return false;\r    }\r    // Check if cache is expired\r    if (Date.now() - entry.timestamp > entry.ttl) {\r      this.cache.delete(key);\r      return false;\r    }\r    return true;\r  }\r  /**\r   * Delete specific key from cache\r   */\r  delete(key: string): void {\r    this.cache.delete(key);\r  }\r  /**\r   * Clear all cache\r   */\r  clear(): void {\r    this.cache.clear();\r  }\r  /**\r   * Clear expired entries\r   */\r  clearExpired(): void {\r    const now = Date.now();\r    for (const [key, entry] of this.cache.entries()) {\r      if (now - entry.timestamp > entry.ttl) {\r        this.cache.delete(key);\r      }\r    }\r  }\r  /**\r   * Get cache size\r   */\r  size(): number {\r    return this.cache.size;\r  }\r  /**\r   * Get all cache keys\r   */\r  keys(): string[] {\r    return Array.from(this.cache.keys());\r  }\r  /**\r   * Cache wrapper for async functions\r   */\r  async withCache<T>(\r    key: string,\r    fetcher: () => Promise<T>,\r    ttl?: number\r  ): Promise<T> {\r    // Check cache first\r    const cached = this.get<T>(key);\r    if (cached !== null) {\r      return cached;\r    }\r    // Fetch data\r    const data = await fetcher();\r    // Store in cache\r    this.set(key, data, ttl);\r    return data;\r  }\r  /**\r   * Invalidate cache by pattern\r   */\r  invalidatePattern(pattern: string | RegExp): void {\r    const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;\r    for (const key of this.cache.keys()) {\r      if (regex.test(key)) {\r        this.cache.delete(key);\r      }\r    }\r  }\r}\r// Export singleton instance\rexport const cacheService = new CacheService();\r// Auto-clear expired entries every 10 minutes\rsetInterval(() => {\r  cacheService.clearExpired();\r}, 10 * 60 * 1000);\rexport default cacheService;",
      "file": "C:/Users/PC/source/repos/Stocker/stocker-web/src/services/cache.service.ts"
    }
  ],
  "C:/Users/PC/source/repos/Stocker/stocker-web/src/shared/utils/rate-limiter.ts": [
    {
      "type": "explicit",
      "line": 1,
      "code": "interface RateLimitConfig {\r  maxRequests: number;\r  windowMs: number;\r  blockDurationMs?: number;\r}\rinterface RequestInfo {\r  count: number;\r  resetTime: number;\r  blocked?: boolean;\r  blockUntil?: number;\r}\rclass RateLimiter {\r  private limits: Map<string, RequestInfo> = new Map();\r  private config: RateLimitConfig;\r  constructor(config: RateLimitConfig) {\r    this.config = {\r      blockDurationMs: 60000, // 1 minute default block\r      ...config,\r    };\r  }\r  isAllowed(key: string): boolean {\r    const now = Date.now();\r    const info = this.limits.get(key);\r    if (!info) {\r      // First request\r      this.limits.set(key, {\r        count: 1,\r        resetTime: now + this.config.windowMs,\r      });\r      return true;\r    }\r    // Check if blocked\r    if (info.blocked && info.blockUntil && now < info.blockUntil) {\r      return false;\r    }\r    // Check if window has passed\r    if (now >= info.resetTime) {\r      // Reset window\r      this.limits.set(key, {\r        count: 1,\r        resetTime: now + this.config.windowMs,\r      });\r      return true;\r    }\r    // Check rate limit\r    if (info.count >= this.config.maxRequests) {\r      // Block the key\r      this.limits.set(key, {\r        ...info,\r        blocked: true,\r        blockUntil: now + this.config.blockDurationMs!,\r      });\r      return false;\r    }\r    // Increment count\r    this.limits.set(key, {\r      ...info,\r      count: info.count + 1,\r    });\r    return true;\r  }\r  reset(key: string): void {\r    this.limits.delete(key);\r  }\r  getRemainingRequests(key: string): number {\r    const info = this.limits.get(key);\r    if (!info) return this.config.maxRequests;\r    const now = Date.now();\r    if (now >= info.resetTime) return this.config.maxRequests;\r    return Math.max(0, this.config.maxRequests - info.count);\r  }\r  getResetTime(key: string): number {\r    const info = this.limits.get(key);\r    return info?.resetTime || Date.now() + this.config.windowMs;\r  }\r  cleanup(): void {\r    const now = Date.now();\r    for (const [key, info] of this.limits.entries()) {\r      if (now >= info.resetTime + this.config.windowMs) {\r        this.limits.delete(key);\r      }\r    }\r  }\r}\r// Create rate limiters for different operations\rexport const loginRateLimiter = new RateLimiter({\r  maxRequests: 5,\r  windowMs: 15 * 60 * 1000, // 15 minutes\r  blockDurationMs: 30 * 60 * 1000, // 30 minutes block\r});\rexport const apiRateLimiter = new RateLimiter({\r  maxRequests: 100,\r  windowMs: 60 * 1000, // 1 minute\r});\rexport const refreshTokenRateLimiter = new RateLimiter({\r  maxRequests: 10,\r  windowMs: 5 * 60 * 1000, // 5 minutes\r});\r// Cleanup old entries every 5 minutes\rif (typeof window !== 'undefined') {\r  setInterval(() => {\r    loginRateLimiter.cleanup();\r    apiRateLimiter.cleanup();\r    refreshTokenRateLimiter.cleanup();\r  }, 5 * 60 * 1000);\r}\r// Exponential backoff for retries\rexport class ExponentialBackoff {\r  private baseDelay: number;\r  private maxDelay: number;\r  private maxRetries: number;\r  private jitter: boolean;\r  constructor(\r    baseDelay = 1000,\r    maxDelay = 30000,\r    maxRetries = 5,\r    jitter = true\r  ) {\r    this.baseDelay = baseDelay;\r    this.maxDelay = maxDelay;\r    this.maxRetries = maxRetries;\r    this.jitter = jitter;\r  }\r  async execute<T>(\r    fn: () => Promise<T>,\r    retryOn?: (error: any) => boolean\r  ): Promise<T> {\r    let lastError: any;\r    for (let attempt = 0; attempt < this.maxRetries; attempt++) {\r      try {\r        return await fn();\r      } catch (error) {\r        lastError = error;\r        // Check if we should retry\r        if (retryOn && !retryOn(error)) {\r          throw error;\r        }\r        // Don't retry on last attempt\r        if (attempt === this.maxRetries - 1) {\r          throw error;\r        }\r        // Calculate delay\r        const delay = this.calculateDelay(attempt);\r        await this.sleep(delay);\r      }\r    }\r    throw lastError;\r  }\r  private calculateDelay(attempt: number): number {\r    let delay = Math.min(this.baseDelay * Math.pow(2, attempt), this.maxDelay);\r    if (this.jitter) {\r      // Add random jitter (±25%)\r      const jitterAmount = delay * 0.25;\r      delay = delay + (Math.random() * 2 - 1) * jitterAmount;\r    }\r    return Math.floor(delay);\r  }\r  private sleep(ms: number): Promise<void> {\r    return new Promise(resolve => setTimeout(resolve, ms));\r  }\r}\r// Request queue for managing concurrent requests\rexport class RequestQueue {\r  private queue: (() => Promise<any>)[] = [];\r  private running = 0;\r  private maxConcurrent: number;\r  constructor(maxConcurrent = 5) {\r    this.maxConcurrent = maxConcurrent;\r  }\r  async add<T>(fn: () => Promise<T>): Promise<T> {\r    return new Promise((resolve, reject) => {\r      this.queue.push(async () => {\r        try {\r          const result = await fn();\r          resolve(result);\r        } catch (error) {\r          reject(error);\r        }\r      });\r      this.process();\r    });\r  }\r  private async process(): Promise<void> {\r    if (this.running >= this.maxConcurrent || this.queue.length === 0) {\r      return;\r    }\r    this.running++;\r    const fn = this.queue.shift();\r    if (fn) {\r      try {\r        await fn();\r      } finally {\r        this.running--;\r        this.process();\r      }\r    }\r  }\r  get pending(): number {\r    return this.queue.length;\r  }\r  get active(): number {\r    return this.running;\r  }\r  clear(): void {\r    this.queue = [];\r  }\r}\r// Global request queue\rexport const globalRequestQueue = new RequestQueue(10);",
      "file": "C:/Users/PC/source/repos/Stocker/stocker-web/src/shared/utils/rate-limiter.ts"
    },
    {
      "type": "genericAny",
      "line": 1,
      "code": "interface RateLimitConfig {\r  maxRequests: number;\r  windowMs: number;\r  blockDurationMs?: number;\r}\rinterface RequestInfo {\r  count: number;\r  resetTime: number;\r  blocked?: boolean;\r  blockUntil?: number;\r}\rclass RateLimiter {\r  private limits: Map<string, RequestInfo> = new Map();\r  private config: RateLimitConfig;\r  constructor(config: RateLimitConfig) {\r    this.config = {\r      blockDurationMs: 60000, // 1 minute default block\r      ...config,\r    };\r  }\r  isAllowed(key: string): boolean {\r    const now = Date.now();\r    const info = this.limits.get(key);\r    if (!info) {\r      // First request\r      this.limits.set(key, {\r        count: 1,\r        resetTime: now + this.config.windowMs,\r      });\r      return true;\r    }\r    // Check if blocked\r    if (info.blocked && info.blockUntil && now < info.blockUntil) {\r      return false;\r    }\r    // Check if window has passed\r    if (now >= info.resetTime) {\r      // Reset window\r      this.limits.set(key, {\r        count: 1,\r        resetTime: now + this.config.windowMs,\r      });\r      return true;\r    }\r    // Check rate limit\r    if (info.count >= this.config.maxRequests) {\r      // Block the key\r      this.limits.set(key, {\r        ...info,\r        blocked: true,\r        blockUntil: now + this.config.blockDurationMs!,\r      });\r      return false;\r    }\r    // Increment count\r    this.limits.set(key, {\r      ...info,\r      count: info.count + 1,\r    });\r    return true;\r  }\r  reset(key: string): void {\r    this.limits.delete(key);\r  }\r  getRemainingRequests(key: string): number {\r    const info = this.limits.get(key);\r    if (!info) return this.config.maxRequests;\r    const now = Date.now();\r    if (now >= info.resetTime) return this.config.maxRequests;\r    return Math.max(0, this.config.maxRequests - info.count);\r  }\r  getResetTime(key: string): number {\r    const info = this.limits.get(key);\r    return info?.resetTime || Date.now() + this.config.windowMs;\r  }\r  cleanup(): void {\r    const now = Date.now();\r    for (const [key, info] of this.limits.entries()) {\r      if (now >= info.resetTime + this.config.windowMs) {\r        this.limits.delete(key);\r      }\r    }\r  }\r}\r// Create rate limiters for different operations\rexport const loginRateLimiter = new RateLimiter({\r  maxRequests: 5,\r  windowMs: 15 * 60 * 1000, // 15 minutes\r  blockDurationMs: 30 * 60 * 1000, // 30 minutes block\r});\rexport const apiRateLimiter = new RateLimiter({\r  maxRequests: 100,\r  windowMs: 60 * 1000, // 1 minute\r});\rexport const refreshTokenRateLimiter = new RateLimiter({\r  maxRequests: 10,\r  windowMs: 5 * 60 * 1000, // 5 minutes\r});\r// Cleanup old entries every 5 minutes\rif (typeof window !== 'undefined') {\r  setInterval(() => {\r    loginRateLimiter.cleanup();\r    apiRateLimiter.cleanup();\r    refreshTokenRateLimiter.cleanup();\r  }, 5 * 60 * 1000);\r}\r// Exponential backoff for retries\rexport class ExponentialBackoff {\r  private baseDelay: number;\r  private maxDelay: number;\r  private maxRetries: number;\r  private jitter: boolean;\r  constructor(\r    baseDelay = 1000,\r    maxDelay = 30000,\r    maxRetries = 5,\r    jitter = true\r  ) {\r    this.baseDelay = baseDelay;\r    this.maxDelay = maxDelay;\r    this.maxRetries = maxRetries;\r    this.jitter = jitter;\r  }\r  async execute<T>(\r    fn: () => Promise<T>,\r    retryOn?: (error: any) => boolean\r  ): Promise<T> {\r    let lastError: any;\r    for (let attempt = 0; attempt < this.maxRetries; attempt++) {\r      try {\r        return await fn();\r      } catch (error) {\r        lastError = error;\r        // Check if we should retry\r        if (retryOn && !retryOn(error)) {\r          throw error;\r        }\r        // Don't retry on last attempt\r        if (attempt === this.maxRetries - 1) {\r          throw error;\r        }\r        // Calculate delay\r        const delay = this.calculateDelay(attempt);\r        await this.sleep(delay);\r      }\r    }\r    throw lastError;\r  }\r  private calculateDelay(attempt: number): number {\r    let delay = Math.min(this.baseDelay * Math.pow(2, attempt), this.maxDelay);\r    if (this.jitter) {\r      // Add random jitter (±25%)\r      const jitterAmount = delay * 0.25;\r      delay = delay + (Math.random() * 2 - 1) * jitterAmount;\r    }\r    return Math.floor(delay);\r  }\r  private sleep(ms: number): Promise<void> {\r    return new Promise(resolve => setTimeout(resolve, ms));\r  }\r}\r// Request queue for managing concurrent requests\rexport class RequestQueue {\r  private queue: (() => Promise<any>)[] = [];\r  private running = 0;\r  private maxConcurrent: number;\r  constructor(maxConcurrent = 5) {\r    this.maxConcurrent = maxConcurrent;\r  }\r  async add<T>(fn: () => Promise<T>): Promise<T> {\r    return new Promise((resolve, reject) => {\r      this.queue.push(async () => {\r        try {\r          const result = await fn();\r          resolve(result);\r        } catch (error) {\r          reject(error);\r        }\r      });\r      this.process();\r    });\r  }\r  private async process(): Promise<void> {\r    if (this.running >= this.maxConcurrent || this.queue.length === 0) {\r      return;\r    }\r    this.running++;\r    const fn = this.queue.shift();\r    if (fn) {\r      try {\r        await fn();\r      } finally {\r        this.running--;\r        this.process();\r      }\r    }\r  }\r  get pending(): number {\r    return this.queue.length;\r  }\r  get active(): number {\r    return this.running;\r  }\r  clear(): void {\r    this.queue = [];\r  }\r}\r// Global request queue\rexport const globalRequestQueue = new RequestQueue(10);",
      "file": "C:/Users/PC/source/repos/Stocker/stocker-web/src/shared/utils/rate-limiter.ts"
    }
  ],
  "C:/Users/PC/source/repos/Stocker/stocker-web/src/features/auth/components/TenantLoginModal/index.tsx": [
    {
      "type": "explicit",
      "line": 130,
      "code": "} catch (err: any) {",
      "file": "C:/Users/PC/source/repos/Stocker/stocker-web/src/features/auth/components/TenantLoginModal/index.tsx"
    }
  ],
  "C:/Users/PC/source/repos/Stocker/stocker-web/src/features/auth/pages/TenantLogin/index.tsx": [
    {
      "type": "explicit",
      "line": 150,
      "code": "} catch (err: any) {",
      "file": "C:/Users/PC/source/repos/Stocker/stocker-web/src/features/auth/pages/TenantLogin/index.tsx"
    }
  ],
  "C:/Users/PC/source/repos/Stocker/stocker-web/src/features/master/pages/Backup/ProfessionalBackup.tsx": [
    {
      "type": "asAny",
      "line": 673,
      "code": "color={getStatusColor(backup.status) as any}",
      "file": "C:/Users/PC/source/repos/Stocker/stocker-web/src/features/master/pages/Backup/ProfessionalBackup.tsx"
    }
  ]
}